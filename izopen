#!/bin/bash
# multi protocol bash script to auto opening given URI and auto creating ssh reverse tunnel socks proxy
# very useful to use KeePassX as secure URI launcher
# Written by Ugo Viti <ugo.viti@initzero.it>
#    date: 20181104
# version: 2.4

# features:
#    URI handling of: ssh, rdp, vnc, sftp, ftp, http, https, smb and cifs protocols

# installation:
#        simply copy this script into a user or system wide bin directory (suggestion: cp izopen ~/bin), must be into a PATH variable

# usage: izopen uri://username:password@hostname:port

# examples:
#        izopen http://www.example.com
#        izopen http://john:doe@www.example.com
#        izopen ssh://root:supersecurepassword@www.example.com
#        izopen smb://Administrator:password@server
#        izopen rdp://DOMAIN/Administrator:password@server
#        izopen rdp:///Administrator:password@server

# KeePassX 0.x integration:
#        into advanded settings of keepassx select "Custom Browser Command" and insert:
#        izopen %1
#        for every account stored into your database, write into URL field: uri://{USERNAME}:{PASSWORD}@host:port
#        example: rdp://{USERNAME}:{PASSWORD}@www.example.com:3389

# KeePassX 2.x integration (Fedora >= 23):
#        dnf install -y zenity kdelibs3 proxychains-ng keepassx


# variables
#########################################################################
debug=1				# enable script debug

helper_http_chrome=1		# use google chrome as web browser (this needed because proxychains doens't works with google chrome)

tunnel_create_force=1		# always create the tunnel for every new ssh connection
tunnel_use_force=1		# always use the tunnel for every opened url
tunnel_use_force_ssh=0		# always use the tunnel if connecting via ssh

izopen_tmp="$HOME/.config/izopen"
izopen_tmp_socks_all="$izopen_tmp/socks_all.conf"
izopen_tmp_socks_last="$izopen_tmp/socks_last.conf"
tunnel_ports_start=2000

[ -f "/tmp/izopen.conf" ] && . /tmp/izopen.conf

# commands helper functions
#########################################################################
helper_ssh() {
  if   [ "$XDG_CURRENT_DESKTOP" = "MATE" ]; then
    helper_cmd_terminal="$(gsettings get org.mate.applications-terminal exec | tr -d \')"
  elif [ "$XDG_CURRENT_DESKTOP" = "GNOME" ]; then
    helper_cmd_terminal="$(gsettings get org.gnome.desktop.default-applications.terminal exec | tr -d \')"
  elif [ "$XDG_CURRENT_DESKTOP" = "KDE" ]; then
    helper_cmd_terminal="$(kreadconfig --file kdeglobals --group General --key TerminalApplication | tr -d \')"
  elif [ "$XDG_CURRENT_DESKTOP" = "XFCE" ]; then
    helper_cmd_terminal="exo-open --launch TerminalEmulator"
   else
    helper_cmd_terminal="terminator"
  fi

  #helper_cmd_terminal="mate-terminal"
  #helper_cmd_terminal="terminator"
  #helper_cmd_terminal="gnome-terminal"
  #helper_cmd_terminal="konsole"
  #helper_cmd_terminal="xfce4-terminal"

  [ -z "$username" ] && read -p "username: " username;
  #[ -z "$password" ] && read -p "password: " password;
  
  helper_cmd_opts="$helper_cmd_opts -C $([ -n "$port" ] && echo "-p $port") $username@$host $opts"

  # set the final command
  helper_cmd="$helper_cmd_terminal --title \"$([ "$tunnel_create" = 1 ] && echo "H:$host P:$tunnel_port_create" || echo "H:$host")\" --command \"ssh $helper_cmd_opts\""

  ####################### 
  # test colorized prompt
  #helper_cmd="gnome-terminal --command \"ssh $([ -n "$port" ] && echo "-p $port") $username@$host $opts\""
  #helper_cmd_ssh_opts="--title \"export PS1='\e[0;31m[\u@\h \W]\$ \e[m '; exec bash\""
}

helper_telnet() {
  helper_cmd_terminal="mate-terminal"
  #helper_cmd_terminal="terminator"
  #helper_cmd_terminal="gnome-terminal"
  #helper_cmd_terminal="konsole"
  #helper_cmd_terminal="xfce4-terminal"

  [ -z "$username" ] && read -p "username: " username;
  #[ -z "$password" ] && read -p "password: " password;
  
  helper_cmd_opts="$helper_cmd_opts $opts $host $([ -n "$port" ] && echo "-p $port")"

  # set the final command
  helper_cmd="$helper_cmd_terminal --title \"$([ "$tunnel_create" = 1 ] && echo "H:$host P:$tunnel_port_create" || echo "H:$host")\" --command \"telnet $helper_cmd_opts\""

  ####################### 
  # test colorized prompt
  #helper_cmd="gnome-terminal --command \"ssh $([ -n "$port" ] && echo "-p $port") $username@$host $opts\""
  #helper_cmd_ssh_opts="--title \"export PS1='\e[0;31m[\u@\h \W]\$ \e[m '; exec bash\""
}


helper_rdp() {
  #helper_cmd_rdp="rdesktop"
  helper_cmd_rdp="xfreerdp"

  # extract windows domain from username and convert to the right name
  if [ ! -z $(echo "$username" | grep "/") ]; then
    domain="$(echo "$username" | awk -F"/" '{print $1}')"
    username="$(echo "$username" | awk -F"/" '{print $2}')"
  fi

  #password="$(echo "$password" | sed -e 's/%\([A-Z]\)/%\L\1/')" # keepassxc bug workaround: after the '%' char, keepassxc convert to uppercase the following char
  password="$(echo "$password" | sed 's/\%25/\%/g' | sed -e 's/%\([A-Z]\)/%\L\1/')" # keepassxc bug workaround: after the '%' char, keepassxc convert to uppercase the following char

  #[ -z "$username" ] && username=$domain && unset domain
  #username="$(echo "$username" | sed 's/\//\\\\/g')"

  case $helper_cmd_rdp in
    rdesktop)
      helper_cmd="$helper_cmd_rdp -k it -g 1280x780 $opts $([ -n "$domain" ] && echo "-d \"$domain\"") $([ -n "$username" ] && echo "-u \"$username\"")  $([ -n "$password" ] && echo "-p \"$password\"") $host$([ -n "$port" ] && echo ":$port")"
      ;;
    xfreerdp)
      helper_cmd="$helper_cmd_rdp /drive:t,/tmp /drive:z,$HOME/download +clipboard /kbd:Italian /size:85% /cert-tofu /cert-ignore $opts $([ -n "$domain" ] && echo "/d:\"$domain\"") $([ -n "$username" ] && echo "/u:$username")  $([ -n "$password" ] && echo "/p:$password") /v:"$host"$([ -n "$port" ] && echo ":$port")"
      ;;
  esac

}

helper_vnc() {
  # vnc doesn't support username and actually don't accept the password. use the gnome keyring instead for this
  helper_cmd="vinagre $protocol://$host$([ -n $port ] && echo ":$port")"
}

helper_sftp() {
  #helper_cmd="xdg-open \"$args\""
  helper_cmd="helper_ssh \"$args\""
}

helper_ftp() {
  helper_cmd="xdg-open \"$args\""
}

helper_http() {
  if [ "$tunnel_use" = 1 ] 
    then
	if [ $helper_http_chrome = 1 ] ; then
	  #helper_cmd="google-chrome --media-cache-size=1 --disk-cache-size=1 --disable-client-side-phishing-detection --disable-gpu --restore-last-session --no-first-run --disable-translate --password-store=basic --user-data-dir=\"$izopen_tmp/google-chrome-$tunnel_port_use\" --proxy-server=\"socks5://localhost:$tunnel_port_use\" \"$args\""
	  helper_cmd="google-chrome --aggressive-cache-discard --disable-notifications --enable-aggressive-domstorage-flushing --disable-client-side-phishing-detection --disable-gpu --restore-last-session --no-first-run --disable-translate --password-store=basic --user-data-dir=\"$izopen_tmp/google-chrome-$tunnel_port_use\" --proxy-server=\"socks5://localhost:$tunnel_port_use\" \"$args\""
	else
	  helper_cmd="midori -c \"$izopen_tmp/midori-$tunnel_port_use\" \"$args\""
	fi
    else
	helper_cmd="xdg-open \"$args\""
  fi
}

helper_https() {
	helper_http "$args"
}

helper_about() {
	helper_http "$args"
}

helper_smb() {
  helper_cmd="xdg-open \"$args\""
}

helper_cifs() {
  helper_cmd="xdg-open \"$args\""
}


# SYSTEM FUNCTIONS
# DON'T TOUCH ANYTHING BELLOW
#########################################################################

helper_tunnel_create() {
 # put specific host port forwarding port config file
 izopen_tmp_socks_host="$izopen_tmp/socks_host_$(echo $host | sed -e 's/[^A-Za-z0-9_-]/_/g').conf"

 # don't create a new tunnel if it's already opened
 if [ -f "$izopen_tmp_socks_host" ]
  then
	nc 127.0.0.1 $(cat "$izopen_tmp_socks_host") </dev/null 2>/dev/null
	[ $? != 0 ] && tunnel_create=1 || tunnel_create=0
 fi
 if [ "$tunnel_create" = 1 ]
  then
	  if   [ ! -e "$izopen_tmp_socks_all" ] ; then
		mkdir -p "$izopen_tmp"
		tunnel_port_create=$tunnel_ports_start
		echo $tunnel_port_create > "$izopen_tmp_socks_all"
	  elif [ -e "$izopen_tmp_socks_host" ] ; then 
		tunnel_port_create="$(cat "$izopen_tmp_socks_host")"
	  elif [ -e "$izopen_tmp_socks_all" ] ; then
		let tunnel_port_create="$(cat "$izopen_tmp_socks_all")+1"
		echo $tunnel_port_create > "$izopen_tmp_socks_all"
	  fi

	  # save the current host used port
	  echo $tunnel_port_create > "$izopen_tmp_socks_host"

	  # save the last used/reused port
	  echo $tunnel_port_create > "$izopen_tmp_socks_last"

	  # dynamic port forwarding with compression
	  # add ssh options to create socks tunnel and compression
	  helper_cmd_opts="-D $tunnel_port_create"
 fi
}

helper_tunnel() {
 tunnel_ports_all="$(cat $izopen_tmp_socks_all 2>/dev/null)"
 tunnel_ports_last="$(cat $izopen_tmp_socks_last 2>/dev/null)"
 [ -z "$tunnel_ports_all" ] && tunnel_ports_all=4999
 [ -z "$tunnel_ports_last" ] && tunnel_ports_last=$tunnel_ports_start

 # don't use tunnel if the protocol is ssh and is not forced
 [[ "$protocol" = "ssh" && "$tunnel_use_force_ssh" = 0 ]] && tunnel_use=0

 # create the ssh tunnel if the url is ssh://
 [ "$protocol" = "ssh" ] && helper_tunnel_create

 # ask for a port if we want use a tunnel
 if [ $tunnel_use = 1 ] ; then
   tunnel_port_use=$(zenity --entry --entry-text=$tunnel_ports_last --text="Inserire la porta del Proxy Socks\nCompresa fra $tunnel_ports_start e $tunnel_ports_all\n" 2>/dev/null)
   # save the last used/reused port
   [ ! -z "$tunnel_port_use" ] && echo $tunnel_port_use > "$izopen_tmp_socks_last"
 fi

 # debug
 #echo tunnel_create=$tunnel_create
 #echo tunnel_use=$tunnel_use
 #echo tunnel_port_use="$tunnel_port_use"

 # create the proxychains4 config
 if [[ ! -z $tunnel_port_use && $tunnel_port_use =~ ^-?[0-9]+$ && $tunnel_port_use -ge $tunnel_ports_start && $tunnel_port_use -le 4999 ]]
  then
        # proxychains configuration
	izopen_tmp_socks_proxy="$izopen_tmp/proxychains.$tunnel_port_use.conf"
        echo -e "strict_chain\nquiet_mode\nproxy_dns\n[ProxyList]\nsocks5  127.0.0.1 $tunnel_port_use" > "$izopen_tmp_socks_proxy"
        helper_cmd_prepend="proxychains4 -f $izopen_tmp_socks_proxy"
  else
    [ ! -z $tunnel_port_use ] && zenity --error --text="La porta specificata non è valida: $tunnel_port_use\n\nInserire una porta compresa fra $tunnel_ports_start e $tunnel_ports_all" 2>/dev/null && unset tunnel_port_use
 fi

 # don't use tunnel socks proxy if the port is not specified or wrong
 [ -z $tunnel_port_use ] && tunnel_use=0
}

print_debug() {
	# print the parsed fields
	echo "========================================================================================"
	echo "$(date +"%Y-%m-%d %H:%M:%S %Z") [debug]: $0 $args"
	echo "----------------------------------------------------------------------------------------"
	echo "       uri: $uri"
	echo "  protocol: $protocol"
	echo "  username: $username"
	echo "  password: $password"
	echo "      host: $host"
	echo "      port: $port"
	echo "      path: $path"
	echo "   uri tmp: $uritmp"
	echo "helper cmd: $helper_cmd"
	echo "========================================================================================"
}

open_uri() {
  local uri="$1"
  local args="$@"
  shift
  local opts="$@"
  url_parse "$uri"

  # workarounds
  [ "${protocol}" = "sftp" ] && protocol="ssh" # force ssh with sftp url

  ##
  ## customize the following uri for command associations:
  ##
  case ${protocol} in
        ssh|telnet|rdp|vnc|sftp|ftp|http|https|about|smb|cifs)
		# create or use ssh tunnel if required
		[[ "$tunnel_create" = 1 || "$tunnel_use" = 1 ]] && helper_tunnel "$args"
		# obtain commands to use to connect
		helper_${protocol} "$args"
		# because google chrome doesn't works with proxychains, I don't use it
		if [[ "$protocol" = "http" && $helper_http_chrome = 1 ]]; then
		  helper_cmd="$helper_cmd"
		else
		  helper_cmd="$helper_cmd_prepend $helper_cmd"
		fi

		[ $debug = 1 ] && print_debug

		# connect to remote server
		eval "$helper_cmd"
		;;
        *)
		echo "ERROR: invalid URI specified: $args"
		;;
  esac
}


#      desc: set/check/sanitize/validate a URI and the gained variables
#      args: $1
# args desc: 'URI'
#    return: misc variables containing the URI data
url_parse() {
    local query1 query2 path1 path2

    # extract the protocolcol
    protourl="$(echo $1 | grep :// | sed -e's,^\(.*://\).*,\1,g')"
    protocol="$(echo $protourl | cut -d":" -f1 )"

    if [[ ! -z $protocol ]] ; then
            # remove the protocol
            url="$(echo ${1/$protourl/})"

            # extract the user (if any)
            login="$(echo $url | grep @ | cut -d@ -f1)"
            username="$(echo $login | cut -d: -f1)"
            password="$(echo $login | grep : | cut -d: -f2)"
	    password="$(echo "$password" | sed 's/!/\\!/g' | sed 's/'\''/\\'\''/g')"

            # extract the host
            hostport="$(echo ${url/$login@/} | cut -d/ -f1)"
            host="$(echo ${hostport} | cut -d: -f1)"

            # by request - try to extract the port
            port="$(echo $hostport | grep ":" | sed -e 's,^.*:,:,g' -e 's,.*:\([0-9]*\).*,\1,g' -e 's,[^0-9],,g')"

            # extract the uri (if any)
            resource="/$(echo $url | grep / | cut -d/ -f2-)"
    else
            url=""
            login=""
            username=""
            password=""
            host=""
            hostname=""
            port=""
            resource=$1
    fi

    # extract the path (if any)
    path1="$(echo $resource | grep ? | cut -d? -f1 )"
    path2="$(echo $resource | grep \# | cut -d# -f1 )"
    path=$path1
    if [[ -z $path ]] ; then path=$path2 ; fi
    if [[ -z $path ]] ; then path=$resource ; fi

    # extract the query (if any)
    query1="$(echo $resource | grep ? | cut -d? -f2-)"
    query2="$(echo $query1 | grep \# | cut -d\# -f1 )"
    query=$query2
    if [[ -z $query ]] ; then query=$query1 ; fi

    # extract the fragment (if any)
    fragment="$(echo $resource | grep \# | cut -d\# -f2 )"

    url="$protourl$url"

    if [ $debug = 2 ]; then
     echo "url: $url"
     echo "protocol: $protocol"
     echo "   login: $login"
     echo "username: $username"
     echo "password: $password"
     echo "    host: $host"
     echo "    port: $port"
     echo "resource: $resource"
     echo "    path: $path"
     echo "   query: $query"
     echo "fragment: $fragment"
     echo ""
    fi
}


case $1 in 
  switch)
	[ -f "/tmp/izopen.conf" ] && . /tmp/izopen.conf
	[ "$tunnel_use_force_ssh" = "0" ] && echo "tunnel_use_force_ssh=1" > /tmp/izopen.conf || echo "tunnel_use_force_ssh=0" > /tmp/izopen.conf
	;;
  tunnel)
	shift
	tunnel_create=1
	tunnel_use=1
	open_uri "$@"
	;;
  clean)
	rm -f "$izopen_tmp"/*.conf
	;;

       *)
	[ $tunnel_create_force = 1 ] && tunnel_create=1
	[ $tunnel_use_force = 1 ] && tunnel_use=1
	open_uri "$@" 2>&1 | tee -a /tmp/izopen.log 2>&1
	;;
esac

